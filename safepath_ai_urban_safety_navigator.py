# -*- coding: utf-8 -*-
"""SafePath AI - Urban Safety Navigator.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NSa1hTThOxZBq3syBg2yxi2NGlUpCPbp
"""

# SafePath AI - Urban Safety Navigator
# Updated Implementation with Gradio Interface

# Import necessary libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import folium
from folium.plugins import HeatMap
from datetime import datetime, timedelta
import random
import os
import io
import base64
import gradio as gr
from PIL import Image

# Set random seed for reproducibility
np.random.seed(42)
random.seed(42)

# ----- DATA GENERATION AND SIMULATION -----

# Function to generate simulated location data for the demo
def generate_city_grid(city_name="Demo City", center_lat=12.9716, center_lon=77.5946):
    """Generate a grid of locations around a city center"""
    # Bangalore coordinates used as default
    grid_size = 10
    lat_span = 0.05
    lon_span = 0.05

    lats = np.linspace(center_lat - lat_span/2, center_lat + lat_span/2, grid_size)
    lons = np.linspace(center_lon - lon_span/2, center_lon + lon_span/2, grid_size)

    locations = []
    for lat in lats:
        for lon in lons:
            locations.append({
                'lat': lat,
                'lon': lon,
                'name': f"Point {len(locations) + 1}"
            })

    return pd.DataFrame(locations)

# Generate sample infrastructure data
def generate_infrastructure_data(city_grid):
    """Generate infrastructure data like streetlights and CCTV cameras"""
    infrastructure = []

    # Generate streetlights
    for _ in range(50):
        # Random point with some clustering toward city center
        idx = np.random.randint(0, len(city_grid))
        base_location = city_grid.iloc[idx]

        # Add some noise to the location
        lat_noise = np.random.normal(0, 0.001)
        lon_noise = np.random.normal(0, 0.001)

        infrastructure.append({
            'type': 'streetlight',
            'lat': base_location['lat'] + lat_noise,
            'lon': base_location['lon'] + lon_noise,
            'working': random.random() > 0.15  # 15% are not working
        })

    # Generate CCTV cameras
    for _ in range(30):
        idx = np.random.randint(0, len(city_grid))
        base_location = city_grid.iloc[idx]

        lat_noise = np.random.normal(0, 0.002)
        lon_noise = np.random.normal(0, 0.002)

        infrastructure.append({
            'type': 'cctv',
            'lat': base_location['lat'] + lat_noise,
            'lon': base_location['lon'] + lon_noise,
            'working': random.random() > 0.1  # 10% are not working
        })

    return pd.DataFrame(infrastructure)

# Generate crime data
def generate_crime_data(city_grid, num_incidents=200, days_back=180):
    """Generate simulated crime data with temporal and spatial patterns"""
    incidents = []

    # Define hotspots (areas with higher crime rates)
    num_hotspots = 3
    hotspot_indices = np.random.choice(len(city_grid), num_hotspots, replace=False)
    hotspots = city_grid.iloc[hotspot_indices]

    # Time patterns - more incidents at night
    timestamps = []
    now = datetime.now()

    for _ in range(num_incidents):
        # Random day within the past 180 days
        days_ago = random.randint(0, days_back)
        incident_date = now - timedelta(days=days_ago)

        # Time distribution - higher probability at night
        hour_weights = [0.02] * 6 + [0.03] * 6 + [0.05] * 6 + [0.15] * 6  # Higher weights from 6PM-6AM
        hour = random.choices(range(24), weights=hour_weights)[0]
        minute = random.randint(0, 59)

        incident_datetime = incident_date.replace(hour=hour, minute=minute)
        timestamps.append(incident_datetime)

    # Location distribution - mixture of hotspots and random locations
    for i in range(num_incidents):
        # 70% near hotspots, 30% random
        if random.random() < 0.7:
            # Pick a hotspot
            hotspot_idx = random.randint(0, num_hotspots - 1)
            base_location = hotspots.iloc[hotspot_idx]

            # Add noise to create cluster
            lat_noise = np.random.normal(0, 0.005)
            lon_noise = np.random.normal(0, 0.005)

            location = {
                'lat': base_location['lat'] + lat_noise,
                'lon': base_location['lon'] + lon_noise
            }
        else:
            # Random location
            idx = np.random.randint(0, len(city_grid))
            base_location = city_grid.iloc[idx]

            lat_noise = np.random.normal(0, 0.01)
            lon_noise = np.random.normal(0, 0.01)

            location = {
                'lat': base_location['lat'] + lat_noise,
                'lon': base_location['lon'] + lon_noise
            }

        incident_types = ['harassment', 'theft', 'assault', 'suspicious_activity']
        weights = [0.4, 0.3, 0.1, 0.2]  # Higher weights for harassment and theft

        incidents.append({
            'type': random.choices(incident_types, weights=weights)[0],
            'datetime': timestamps[i],
            'lat': location['lat'],
            'lon': location['lon'],
            'reported_by': 'police' if random.random() < 0.6 else 'user'
        })

    return pd.DataFrame(incidents)

# Generate user sentiment data
def generate_user_sentiment(city_grid, num_ratings=300):
    """Generate simulated user safety ratings"""
    ratings = []

    for _ in range(num_ratings):
        # Random location with some clustering
        idx = np.random.randint(0, len(city_grid))
        base_location = city_grid.iloc[idx]

        lat_noise = np.random.normal(0, 0.002)
        lon_noise = np.random.normal(0, 0.002)

        # Time of rating
        days_ago = random.randint(0, 90)  # Past 90 days
        hours_ago = random.randint(0, 24)
        rating_time = datetime.now() - timedelta(days=days_ago, hours=hours_ago)

        # Higher ratings (safer) during daytime
        is_daytime = 6 <= rating_time.hour <= 18
        base_rating = random.normalvariate(4.0, 0.5) if is_daytime else random.normalvariate(3.0, 1.0)
        safety_rating = max(min(round(base_rating, 1), 5.0), 1.0)  # Clamp between 1-5

        ratings.append({
            'lat': base_location['lat'] + lat_noise,
            'lon': base_location['lon'] + lon_noise,
            'timestamp': rating_time,
            'safety_rating': safety_rating,
            'comment': "",  # In a real app, this would contain user comments
            'daytime': is_daytime
        })

    return pd.DataFrame(ratings)

# Generate transit data
def generate_transit_data(city_grid):
    """Generate public transit information like bus stops and metro stations"""
    transit = []

    # Generate bus stops
    for i in range(20):
        idx = np.random.randint(0, len(city_grid))
        base_location = city_grid.iloc[idx]

        lat_noise = np.random.normal(0, 0.001)
        lon_noise = np.random.normal(0, 0.001)

        transit.append({
            'type': 'bus_stop',
            'id': f'B{i+1:02d}',
            'name': f'Bus Stop {i+1}',
            'lat': base_location['lat'] + lat_noise,
            'lon': base_location['lon'] + lon_noise,
            'routes': random.sample(['12A', '205D', '500', '300B', '101', '44C'], k=random.randint(1, 3))
        })

    # Generate metro stations
    for i in range(8):
        idx = np.random.randint(0, len(city_grid))
        base_location = city_grid.iloc[idx]

        lat_noise = np.random.normal(0, 0.001)
        lon_noise = np.random.normal(0, 0.001)

        transit.append({
            'type': 'metro',
            'id': f'M{i+1}',
            'name': f'Metro Station {i+1}',
            'lat': base_location['lat'] + lat_noise,
            'lon': base_location['lon'] + lon_noise,
            'lines': random.sample(['Red', 'Blue', 'Green', 'Purple'], k=random.randint(1, 2))
        })

    return pd.DataFrame(transit)

# ----- SAFETY ANALYTICS ENGINE -----

# Calculate safety score based on multiple factors
def calculate_safety_score(lat, lon, time_of_day, city_grid, crime_data, infrastructure, sentiments):
    """Calculate a safety score for a given location and time"""
    # Parameters
    crime_weight = 0.4
    infra_weight = 0.3
    sentiment_weight = 0.3

    # Time factor - night is considered less safe
    hour = time_of_day.hour
    is_night = hour < 6 or hour >= 18
    time_factor = 0.7 if is_night else 1.0

    # Crime score - based on proximity to recent incidents
    max_crime_dist = 0.01  # approximately 1km
    nearby_crimes = crime_data[
        (abs(crime_data['lat'] - lat) < max_crime_dist) &
        (abs(crime_data['lon'] - lon) < max_crime_dist)
    ]

    # Weight recent crimes more heavily
    crime_recency_weights = []
    for crime_time in nearby_crimes['datetime']:
        days_ago = (datetime.now() - crime_time).days
        # Exponential decay - older crimes matter less
        weight = np.exp(-0.05 * days_ago)
        crime_recency_weights.append(weight)

    if len(nearby_crimes) > 0:
        crime_score = 1.0 - min(len(nearby_crimes) * np.mean(crime_recency_weights) * 0.1, 0.9)
    else:
        crime_score = 1.0

    # Infrastructure score - based on streetlights and CCTV
    max_infra_dist = 0.005  # approximately 500m
    nearby_infra = infrastructure[
        (abs(infrastructure['lat'] - lat) < max_infra_dist) &
        (abs(infrastructure['lon'] - lon) < max_infra_dist) &
        (infrastructure['working'] == True)
    ]

    # Count working streetlights and CCTV
    streetlights = nearby_infra[nearby_infra['type'] == 'streetlight']
    cctvs = nearby_infra[nearby_infra['type'] == 'cctv']

    # More important at night
    if is_night:
        # At night, streetlights matter a lot
        infra_score = min((len(streetlights) * 0.15 + len(cctvs) * 0.1), 1.0)
    else:
        # During day, CCTV matters more
        infra_score = min((len(streetlights) * 0.05 + len(cctvs) * 0.15), 1.0)

    # User sentiment score
    max_sentiment_dist = 0.005  # approximately 500m
    nearby_ratings = sentiments[
        (abs(sentiments['lat'] - lat) < max_sentiment_dist) &
        (abs(sentiments['lon'] - lon) < max_sentiment_dist)
    ]

    # Filter ratings by time of day
    current_daytime = 6 <= hour <= 18
    relevant_ratings = nearby_ratings[nearby_ratings['daytime'] == current_daytime]

    if len(relevant_ratings) > 0:
        sentiment_score = relevant_ratings['safety_rating'].mean() / 5.0
    else:
        # If no ratings for this time of day, use all ratings with a penalty
        if len(nearby_ratings) > 0:
            sentiment_score = (nearby_ratings['safety_rating'].mean() / 5.0) * 0.8
        else:
            sentiment_score = 0.5  # Neutral if no data

    # Combined score (0-100)
    raw_score = (
        crime_score * crime_weight +
        infra_score * infra_weight +
        sentiment_score * sentiment_weight
    ) * time_factor

    return min(max(raw_score * 100, 20), 100)  # Clamp between 20-100

# Function to find the safest route between two points
def find_safest_route(start_lat, start_lon, end_lat, end_lon, current_time,
                      city_grid, crime_data, infrastructure, sentiments):
    """Find the safest route between two points using a grid-based approach"""
    # For the demo, we'll simulate 3 different routes with different safety profiles
    routes = []

    # Direct route (shortest)
    direct_points = []
    num_segments = 5
    for i in range(num_segments + 1):
        # Linear interpolation between start and end
        factor = i / num_segments
        lat = start_lat + factor * (end_lat - start_lat)
        lon = start_lon + factor * (end_lon - start_lon)

        # Calculate safety score for this point
        safety = calculate_safety_score(lat, lon, current_time,
                                       city_grid, crime_data, infrastructure, sentiments)

        direct_points.append((lat, lon, safety))

    # Calculate route stats
    avg_safety = sum(point[2] for point in direct_points) / len(direct_points)
    min_safety = min(point[2] for point in direct_points)

    direct_route = {
        'name': 'Route A (Direct)',
        'points': direct_points,
        'avg_safety': avg_safety,
        'min_safety': min_safety,
        'distance': 1.0,  # Normalized distance
        'est_time': '15 min'
    }
    routes.append(direct_route)

    # Alternative route 1 (safer but longer)
    # Add some deviation to create a different path
    alt1_points = []
    deviation_lat = (end_lat - start_lat) * 0.2
    deviation_lon = (end_lon - start_lon) * 0.2

    # First segment - from start to midpoint with deviation
    mid_lat = (start_lat + end_lat) / 2 + deviation_lat
    mid_lon = (start_lon + end_lon) / 2 + deviation_lon

    for i in range(4):
        factor = i / 3
        lat = start_lat + factor * (mid_lat - start_lat)
        lon = start_lon + factor * (mid_lon - start_lon)

        safety = calculate_safety_score(lat, lon, current_time,
                                       city_grid, crime_data, infrastructure, sentiments)
        # Boost safety for this route
        safety = min(safety * 1.15, 100)

        alt1_points.append((lat, lon, safety))

    # Second segment - from midpoint to end
    for i in range(1, 4):  # Skip midpoint as it's already added
        factor = i / 3
        lat = mid_lat + factor * (end_lat - mid_lat)
        lon = mid_lon + factor * (end_lon - mid_lon)

        safety = calculate_safety_score(lat, lon, current_time,
                                       city_grid, crime_data, infrastructure, sentiments)
        # Boost safety for this route
        safety = min(safety * 1.15, 100)

        alt1_points.append((lat, lon, safety))

    avg_safety = sum(point[2] for point in alt1_points) / len(alt1_points)
    min_safety = min(point[2] for point in alt1_points)

    alt1_route = {
        'name': 'Route B (Safer)',
        'points': alt1_points,
        'avg_safety': avg_safety,
        'min_safety': min_safety,
        'distance': 1.3,  # 30% longer than direct route
        'est_time': '20 min'
    }
    routes.append(alt1_route)

    # Alternative route 2 (different path)
    alt2_points = []
    deviation_lat = (end_lat - start_lat) * -0.15
    deviation_lon = (end_lon - start_lon) * -0.15

    # Use a different midpoint
    mid_lat = (start_lat + end_lat) / 2 + deviation_lat
    mid_lon = (start_lon + end_lon) / 2 + deviation_lon

    for i in range(4):
        factor = i / 3
        lat = start_lat + factor * (mid_lat - start_lat)
        lon = start_lon + factor * (mid_lon - start_lon)

        safety = calculate_safety_score(lat, lon, current_time,
                                       city_grid, crime_data, infrastructure, sentiments)
        # Slightly reduce safety for this route
        safety = max(safety * 0.9, 20)

        alt2_points.append((lat, lon, safety))

    # Second segment
    for i in range(1, 4):
        factor = i / 3
        lat = mid_lat + factor * (end_lat - mid_lat)
        lon = mid_lon + factor * (end_lon - mid_lon)

        safety = calculate_safety_score(lat, lon, current_time,
                                       city_grid, crime_data, infrastructure, sentiments)
        # Slightly reduce safety for this route
        safety = max(safety * 0.9, 20)

        alt2_points.append((lat, lon, safety))

    avg_safety = sum(point[2] for point in alt2_points) / len(alt2_points)
    min_safety = min(point[2] for point in alt2_points)

    alt2_route = {
        'name': 'Route C (Fastest)',
        'points': alt2_points,
        'avg_safety': avg_safety,
        'min_safety': min_safety,
        'distance': 1.1,  # 10% longer than direct route
        'est_time': '12 min'
    }
    routes.append(alt2_route)

    # Sort routes by average safety score (highest first)
    routes.sort(key=lambda r: r['avg_safety'], reverse=True)

    return routes

# Generate safety heatmap
def generate_safety_heatmap(center_lat, center_lon, current_time, city_grid,
                           crime_data, infrastructure, sentiments):
    """Generate safety heatmap data for visualization"""
    # Create a grid around the center point
    grid_size = 20
    lat_span = 0.02
    lon_span = 0.02

    lats = np.linspace(center_lat - lat_span, center_lat + lat_span, grid_size)
    lons = np.linspace(center_lon - lon_span, center_lon + lon_span, grid_size)

    heatmap_data = []
    for lat in lats:
        for lon in lons:
            safety = calculate_safety_score(lat, lon, current_time,
                                           city_grid, crime_data, infrastructure, sentiments)

            # Invert score for heatmap (higher value = more unsafe = hotter)
            heatmap_value = (100 - safety) / 100

            heatmap_data.append([lat, lon, heatmap_value])

    return heatmap_data

# Function to get transit safety information
def get_transit_safety(transit_data, current_time, city_grid, crime_data, infrastructure, sentiments):
    """Get safety scores for transit locations"""
    transit_safety = []

    for _, transit in transit_data.iterrows():
        safety = calculate_safety_score(
            transit['lat'], transit['lon'], current_time,
            city_grid, crime_data, infrastructure, sentiments
        )

        # Simulate occupancy data
        hour = current_time.hour
        is_rush_hour = (7 <= hour <= 10) or (16 <= hour <= 19)

        if is_rush_hour:
            occupancy = random.randint(70, 95)
        else:
            occupancy = random.randint(20, 60)

        # Calculate women percentage - typically higher during day
        is_daytime = 6 <= hour <= 20
        if is_daytime:
            women_percent = random.randint(40, 60)
        else:
            women_percent = random.randint(20, 40)

        # Special case for bus routes
        routes_info = []
        if transit['type'] == 'bus_stop':
            for route in transit['routes']:
                # Simulate data for each route
                routes_info.append({
                    'route': route,
                    'next_arrival': f"{random.randint(1, 20)} min",
                    'occupancy': random.randint(max(0, occupancy-20), min(100, occupancy+20)),
                    'women_percent': random.randint(max(0, women_percent-15), min(100, women_percent+15)),
                    'safety_rating': min(max(safety + random.uniform(-10, 10), 20), 100)
                })

        # Special case for metro lines
        lines_info = []
        if transit['type'] == 'metro':
            for line in transit['lines']:
                lines_info.append({
                    'line': line,
                    'next_arrival': f"{random.randint(1, 15)} min",
                    'occupancy': random.randint(max(0, occupancy-10), min(100, occupancy+10)),
                    'women_percent': random.randint(max(0, women_percent-10), min(100, women_percent+10)),
                    'women_only_car': random.choice([True, False]),
                    'safety_rating': min(max(safety + random.uniform(-5, 10), 20), 100)
                })

        transit_info = {
            'id': transit['id'],
            'name': transit['name'],
            'type': transit['type'],
            'lat': transit['lat'],
            'lon': transit['lon'],
            'safety_score': safety,
            'occupancy': occupancy,
            'women_percent': women_percent
        }

        if transit['type'] == 'bus_stop':
            transit_info['routes'] = routes_info
        elif transit['type'] == 'metro':
            transit_info['lines'] = lines_info

        transit_safety.append(transit_info)

    return transit_safety

# Predictive features for potential safety issues
def predict_safety_alerts(lat, lon, current_time, city_grid, crime_data, infrastructure, sentiments, transit_data):
    """Predict potential safety issues based on current conditions"""
    alerts = []

    # Check time of day
    hour = current_time.hour
    is_night = hour < 6 or hour >= 19

    # Check if it's weekend
    is_weekend = current_time.weekday() >= 5

    # Simulate weather conditions (in a real app, this would come from a weather API)
    weather_conditions = random.choice(['clear', 'rain', 'overcast'])
    is_rainy = weather_conditions == 'rain'

    # Alert for nighttime + poor infrastructure
    if is_night:
        # Check streetlight coverage
        radius = 0.005  # ~500m
        nearby_lights = infrastructure[
            (abs(infrastructure['lat'] - lat) < radius) &
            (abs(infrastructure['lon'] - lon) < radius) &
            (infrastructure['type'] == 'streetlight') &
            (infrastructure['working'] == True)
        ]

        if len(nearby_lights) < 3:
            alerts.append({
                'type': 'low_lighting',
                'severity': 'medium',
                'message': "Limited streetlight coverage in this area at night. Consider well-lit main roads."
            })

    # Alert for rainy conditions
    if is_rainy:
        alerts.append({
            'type': 'weather',
            'severity': 'low',
            'message': f"Rain forecast. Expect 30% fewer people on streets and reduced visibility."
        })

    # Alert for recent incidents
    recent_window = current_time - timedelta(days=7)
    recent_incidents = crime_data[
        (abs(crime_data['lat'] - lat) < 0.01) &
        (abs(crime_data['lon'] - lon) < 0.01) &
        (crime_data['datetime'] > recent_window)
    ]

    if len(recent_incidents) >= 3:
        alerts.append({
            'type': 'recent_incidents',
            'severity': 'high',
            'message': f"{len(recent_incidents)} safety incidents reported nearby in the past week."
        })

    # Alert for low occupancy at transit points
    if is_night:
        nearby_transit = transit_data[
            (abs(transit_data['lat'] - lat) < 0.01) &
            (abs(transit_data['lon'] - lon) < 0.01)
        ]

        for _, transit in nearby_transit.iterrows():
            if transit['type'] == 'metro':
                name = transit['name']
                alerts.append({
                    'type': 'low_occupancy',
                    'severity': 'medium',
                    'message': f"{name} has 40% fewer commuters tonight. Consider sharing your trip status."
                })

    # Weekend nightlife alert
    if is_weekend and (22 <= hour or hour <= 2):
        alerts.append({
            'type': 'nightlife',
            'severity': 'medium',
            'message': "Active nightlife area. Higher than usual foot traffic expected."
        })

    return alerts

# Generate SafeZone buddy matches
def find_safezone_buddies(start_lat, start_lon, end_lat, end_lon, departure_time):
    """Find potential travel buddies heading the same way"""
    # In a real app, this would query a database of active user trips
    # For the demo, we'll simulate some potential matches

    # Generate between 0-3 matches
    num_matches = random.randint(0, 3)
    if num_matches == 0:
        return []

    matches = []
    for i in range(num_matches):
        # Simulate a user with similar route
        start_lat_noise = random.uniform(-0.002, 0.002)
        start_lon_noise = random.uniform(-0.002, 0.002)
        end_lat_noise = random.uniform(-0.003, 0.003)
        end_lon_noise = random.uniform(-0.003, 0.003)

        # Time window (minutes before/after requested departure)
        time_window = random.randint(-10, 15)
        match_departure = departure_time + timedelta(minutes=time_window)

        # Match verification status
        is_verified = random.random() < 0.7  # 70% are verified

        matches.append({
            'user_id': f"user_{random.randint(1000, 9999)}",
            'rating': round(random.uniform(4.0, 5.0), 1),
            'trips_completed': random.randint(3, 50),
            'start_lat': start_lat + start_lat_noise,
            'start_lon': start_lon + start_lon_noise,
            'end_lat': end_lat + end_lat_noise,
            'end_lon': end_lon + end_lon_noise,
            'departure_time': match_departure,
            'verified': is_verified
        })

    return matches

# ----- VISUALIZATION FUNCTIONS -----

# Create a map with safety heatmap overlay
def create_safety_map(center_lat, center_lon, heatmap_data=None, routes=None,
                     infrastructure=None, transit=None):
    """Create an interactive map with safety visualization"""
    # Create base map
    m = folium.Map(location=[center_lat, center_lon], zoom_start=14)

    # Add heatmap if provided
    if heatmap_data is not None:
        HeatMap(
            heatmap_data,
            radius=15,
            gradient={0.2: 'blue', 0.4: 'lime', 0.6: 'yellow', 0.8: 'orange', 1: 'red'},
            max_zoom=13
        ).add_to(m)

    # Add routes if provided
    if routes is not None:
        for i, route in enumerate(routes):
            # Choose color based on safety
            avg_safety = route['avg_safety']
            if avg_safety >= 80:
                color = '#087f23'  # Dark green
            elif avg_safety >= 60:
                color = '#4caf50'  # Green
            elif avg_safety >= 40:
                color = '#ff9800'  # Orange
            else:
                color = '#d32f2f'  # Red

            # Extract points
            points = [(p[0], p[1]) for p in route['points']]

            # Draw route line
            folium.PolyLine(
                points,
                color=color,
                weight=5,
                opacity=0.7,
                popup=f"{route['name']} - {route['avg_safety']:.1f}% Safe"
            ).add_to(m)

            # Mark start and end
            folium.Marker(
                points[0],
                icon=folium.Icon(color='blue', icon='play', prefix='fa'),
                popup="Start"
            ).add_to(m)

            folium.Marker(
                points[-1],
                icon=folium.Icon(color='green', icon='flag-checkered', prefix='fa'),
                popup="Destination"
            ).add_to(m)

    # Add infrastructure if provided
    if infrastructure is not None:
        for _, infra in infrastructure.iterrows():
            if infra['type'] == 'streetlight':
                # Streetlight icon
                icon_color = 'lightgreen' if infra['working'] else 'gray'
                folium.CircleMarker(
                    location=[infra['lat'], infra['lon']],
                    radius=3,
                    color=icon_color,
                    fill=True,
                    fill_opacity=0.7,
                    popup="Streetlight" + (" (Working)" if infra['working'] else " (Out of Order)")
                ).add_to(m)
            elif infra['type'] == 'cctv':
                # CCTV icon
                icon_color = 'blue' if infra['working'] else 'gray'
                folium.CircleMarker(
                    location=[infra['lat'], infra['lon']],
                    radius=4,
                    color=icon_color,
                    fill=True,
                    fill_opacity=0.7,
                    popup="CCTV Camera" + (" (Working)" if infra['working'] else " (Out of Order)")
                ).add_to(m)

    # Add transit locations if provided
    if transit is not None:
        for transit_point in transit:
            # Choose icon based on transit type
            if transit_point['type'] == 'bus_stop':
                icon = folium.Icon(color='blue', icon='bus', prefix='fa')
            elif transit_point['type'] == 'metro':
                icon = folium.Icon(color='red', icon='subway', prefix='fa')
            else:
                icon = folium.Icon(color='gray', icon='question', prefix='fa')

            # Create popup with safety info
            popup_html = f"""
            <div style="width:200px">
                <h4>{transit_point['name']}</h4>
                <p>Safety Score: {transit_point['safety_score']:.1f}%</p>
                <p>Current Occupancy: ~{transit_point['occupancy']}%</p>
                <p>Women Travelers: ~{transit_point['women_percent']}%</p>
            </div>
            """

            folium.Marker(
                location=[transit_point['lat'], transit_point['lon']],
                icon=icon,
                popup=folium.Popup(popup_html, max_width=300)
            ).add_to(m)

    return m

# Generate visual safety report
def create_safety_report(lat, lon, current_time, city_grid, crime_data, infrastructure, sentiments):
    """Create visualizations for safety report"""
    # Set figure size
    plt.figure(figsize=(12, 9))

    # Calculate safety score
    safety_score = calculate_safety_score(lat, lon, current_time, city_grid, crime_data, infrastructure, sentiments)

    # 1. Safety score gauge
    plt.subplot(2, 2, 1)
    plt.pie([safety_score, 100-safety_score], colors=['#4CAF50', '#ECEFF1'],
            startangle=90, counterclock=False)
    plt.text(0, 0, f"{safety_score:.1f}%", fontsize=24, ha='center', va='center')
    plt.title('Current Safety Score', fontsize=14)
    plt.axis('equal')

    # 2. Recent incidents by time
    plt.subplot(2, 2, 2)
    # Filter incidents within ~1km
    max_dist = 0.01
    nearby_incidents = crime_data[
        (abs(crime_data['lat'] - lat) < max_dist) &
        (abs(crime_data['lon'] - lon) < max_dist)
    ]

    # Get incidents by hour
    hours = nearby_incidents['datetime'].apply(lambda x: x.hour)
    hour_counts = hours.value_counts().sort_index()
    hour_bins = range(24)
    incident_counts = [hour_counts.get(hour, 0) for hour in hour_bins]

    # Plot
    plt.bar(hour_bins, incident_counts, color='#FFA726')
    plt.title('Incidents by Hour (Past 180 Days)', fontsize=14)
    plt.xlabel('Hour of Day')
    plt.ylabel('Number of Incidents')
    plt.xticks([0, 6, 12, 18, 23])

    # 3. Infrastructure
    plt.subplot(2, 2, 3)
    # Count infrastructure within ~500m
    max_infra_dist = 0.005
    nearby_infra = infrastructure[
        (abs(infrastructure['lat'] - lat) < max_infra_dist) &
        (abs(infrastructure['lon'] - lon) < max_infra_dist)
    ]

    # Count working/non-working by type
    streetlights_working = sum((nearby_infra['type'] == 'streetlight') & (nearby_infra['working'] == True))
    streetlights_broken = sum((nearby_infra['type'] == 'streetlight') & (nearby_infra['working'] == False))
    cctv_working = sum((nearby_infra['type'] == 'cctv') & (nearby_infra['working'] == True))
    cctv_broken = sum((nearby_infra['type'] == 'cctv') & (nearby_infra['working'] == False))

    labels = ['Working Streetlights', 'Broken Streetlights', 'Working CCTV', 'Broken CCTV']
    counts = [streetlights_working, streetlights_broken, cctv_working, cctv_broken]
    colors = ['#4CAF50', '#F44336', '#2196F3', '#F44336']

    plt.bar(labels, counts, color=colors)
    plt.title('Infrastructure within 500m', fontsize=14)
    plt.ylabel('Count')
    plt.xticks(rotation=45, ha='right')

    # 4. User Sentiment by Time of Day
    plt.subplot(2, 2, 4)
    # Filter user sentiments
    max_sentiment_dist = 0.01
    nearby_sentiments = sentiments[
        (abs(sentiments['lat'] - lat) < max_sentiment_dist) &
        (abs(sentiments['lon'] - lon) < max_sentiment_dist)
    ]

    # Group by daytime/nighttime
    daytime_ratings = nearby_sentiments[nearby_sentiments['daytime'] == True]['safety_rating']
    nighttime_ratings = nearby_sentiments[nearby_sentiments['daytime'] == False]['safety_rating']

    # Calculate average ratings
    daytime_avg = daytime_ratings.mean() if len(daytime_ratings) > 0 else 0
    nighttime_avg = nighttime_ratings.mean() if len(nighttime_ratings) > 0 else 0

    # Plot
    time_labels = ['Day', 'Night']
    avg_ratings = [daytime_avg, nighttime_avg]
    plt.bar(time_labels, avg_ratings, color=['#FFC107', '#673AB7'])
    plt.title('Average User Safety Rating (1-5)', fontsize=14)
    plt.ylabel('Rating')
    plt.ylim(0, 5)

    plt.tight_layout()

    # Convert plot to image for Gradio
    buf = io.BytesIO()
    plt.savefig(buf, format='png')
    buf.seek(0)

    return Image.open(buf)

# ----- GRADIO INTERFACE -----

# Initialize data (would be loaded from database in a real app)
city_grid = generate_city_grid()
infrastructure_data = generate_infrastructure_data(city_grid)
crime_data = generate_crime_data(city_grid)
sentiment_data = generate_user_sentiment(city_grid)
transit_data = generate_transit_data(city_grid)

def format_map_html(map_obj):
    """Convert folium map to HTML for display in Gradio"""
    html_string = map_obj._repr_html_()
    return html_string

def format_route_comparison(routes):
    """Format route comparison for display"""
    html = "<div style='padding:10px'>"
    html += "<h3>Route Comparison</h3>"

    # Create comparison table
    html += "<table style='width:100%; border-collapse:collapse; margin-bottom:20px'>"
    html += "<tr style='background-color:#f0f0f0'><th style='padding:8px; text-align:left'>Route</th><th>Avg Safety</th><th>Min Safety</th><th>Distance</th><th>Est. Time</th></tr>"

    for route in routes:
        safety_color = "#4CAF50" if route['avg_safety'] >= 75 else "#FF9800" if route['avg_safety'] >= 50 else "#F44336"

        html += f"<tr style='border-bottom:1px solid #ddd'>"
        html += f"<td style='padding:8px'>{route['name']}</td>"
        html += f"<td style='text-align:center'><span style='color:{safety_color}; font-weight:bold'>{route['avg_safety']:.1f}%</span></td>"
        html += f"<td style='text-align:center'>{route['min_safety']:.1f}%</td>"
        html += f"<td style='text-align:center'>{route['distance']:.1f}x</td>"
        html += f"<td style='text-align:center'>{route['est_time']}</td>"
        html += "</tr>"

    html += "</table>"

    # Recommendation
    safest_route = max(routes, key=lambda r: r['avg_safety'])
    fastest_route = min(routes, key=lambda r: float(r['est_time'].split()[0]))

    html += "<div style='background-color:#e8f5e9; padding:10px; border-radius:5px; margin-bottom:10px'>"
    html += f"<h4>Recommended: {safest_route['name']}</h4>"
    html += "<p>This route offers the best balance of safety and travel time</p>"
    html += "</div>"

    if safest_route != fastest_route:
        html += "<p><i>Note: The fastest route has a lower safety score. Consider travel companions or time of day.</i></p>"

    html += "</div>"

    return html

def format_transit_info(transit_safety):
    """Format transit safety information for display"""
    html = "<div style='padding:10px'>"
    html += "<h3>Transit Options</h3>"

    # Filter to show only the closest 5 transit points
    closest_transit = sorted(transit_safety, key=lambda t: t['safety_score'], reverse=True)[:5]

    for transit in closest_transit:
        # Set color based on safety score
        if transit['safety_score'] >= 80:
            safety_color = "#4CAF50"  # Green
        elif transit['safety_score'] >= 60:
            safety_color = "#8BC34A"  # Light Green
        elif transit['safety_score'] >= 40:
            safety_color = "#FFC107"  # Amber
        else:
            safety_color = "#F44336"  # Red

        # Create card for transit point
        html += f"<div style='border:1px solid #ddd; border-radius:5px; margin-bottom:15px; background-color:#fff'>"
        html += f"<div style='background-color:{safety_color}; color:white; padding:8px; border-radius:5px 5px 0 0'>"
        html += f"<h4 style='margin:0'>{transit['name']} ({transit['type'].replace('_', ' ').title()})</h4>"
        html += "</div>"
        html += f"<div style='padding:10px'>"
        html += f"<p>Safety Score: <b>{transit['safety_score']:.1f}%</b></p>"
        html += f"<p>Current Occupancy: ~{transit['occupancy']}%</p>"
        html += f"<p>Women Travelers: ~{transit['women_percent']}%</p>"

        # Show routes for bus stops
        if transit['type'] == 'bus_stop' and 'routes' in transit:
            html += "<table style='width:100%; font-size:0.9em; margin-top:10px'>"
            html += "<tr style='background-color:#f0f0f0'><th>Route</th><th>Next Arrival</th><th>Occupancy</th><th>Safety</th></tr>"

            for route in transit['routes']:
                html += f"<tr>"
                html += f"<td>{route['route']}</td>"
                html += f"<td>{route['next_arrival']}</td>"
                html += f"<td>{route['occupancy']}%</td>"
                html += f"<td>{route['safety_rating']:.1f}%</td>"
                html += "</tr>"

            html += "</table>"

        # Show lines for metro stations
        if transit['type'] == 'metro' and 'lines' in transit:
            html += "<table style='width:100%; font-size:0.9em; margin-top:10px'>"
            html += "<tr style='background-color:#f0f0f0'><th>Line</th><th>Next Train</th><th>Women-Only Car</th><th>Safety</th></tr>"

            for line in transit['lines']:
                html += f"<tr>"
                html += f"<td>{line['line']} Line</td>"
                html += f"<td>{line['next_arrival']}</td>"
                html += f"<td>{'Yes' if 'women_only_car' in line and line['women_only_car'] else 'No'}</td>"
                html += f"<td>{line['safety_rating']:.1f}%</td>"
                html += "</tr>"

            html += "</table>"

        html += "</div></div>"

    html += "</div>"

    return html

def format_safety_alerts(alerts):
    """Format safety alerts for display"""
    if not alerts:
        return "<div style='padding:10px'><p>No safety alerts for this area at this time.</p></div>"

    html = "<div style='padding:10px'>"
    html += "<h3>Safety Alerts</h3>"

    for alert in alerts:
        # Set color based on severity
        if alert['severity'] == 'high':
            color = "#F44336"  # Red
            icon = "‚ö†Ô∏è"
        elif alert['severity'] == 'medium':
            color = "#FF9800"  # Orange
            icon = "‚ö†Ô∏è"
        else:
            color = "#2196F3"  # Blue
            icon = "‚ÑπÔ∏è"

        html += f"<div style='border-left:4px solid {color}; background-color:#f9f9f9; padding:10px; margin-bottom:10px'>"
        html += f"<p><b>{icon} {alert['type'].replace('_', ' ').title()}</b></p>"
        html += f"<p>{alert['message']}</p>"
        html += "</div>"

    html += "</div>"

    return html

def format_safezone_buddies(buddies):
    """Format SafeZone buddy matches for display"""
    if not buddies:
        return "<div style='padding:10px'><p>No SafeZone buddy matches available for this route and time.</p></div>"

    html = "<div style='padding:10px'>"
    html += "<h3>SafeZone Buddy Matches</h3>"

    html += "<p>These travelers are heading the same way around the same time:</p>"

    for buddy in buddies:
        # Set up the buddy card
        html += f"<div style='border:1px solid #ddd; border-radius:5px; padding:10px; margin-bottom:10px; background-color:#f9f9f9'>"

        # User info section
        html += f"<div style='display:flex; align-items:center; margin-bottom:10px'>"
        html += f"<div style='width:50px; height:50px; background-color:#2196F3; border-radius:50%; color:white; display:flex; align-items:center; justify-content:center; margin-right:10px'>"
        html += f"<span style='font-size:1.2em'>üë§</span>"
        html += f"</div>"
        html += f"<div>"
        html += f"<div><b>User {buddy['user_id'].split('_')[1]}</b> {' ‚úì' if buddy['verified'] else ''}</div>"
        html += f"<div>‚≠ê {buddy['rating']} ‚Ä¢ {buddy['trips_completed']} trips</div>"
        html += f"</div>"
        html += f"</div>"

        # Trip details
        dep_time = buddy['departure_time'].strftime('%I:%M %p')
        html += f"<div style='margin-top:5px'><b>Departure:</b> {dep_time}</div>"

        # Add match button (in a real app, this would be functional)
        html += f"<button style='background-color:#4CAF50; color:white; border:none; padding:8px 16px; margin-top:10px; border-radius:4px; cursor:pointer'>Request Match</button>"

        html += "</div>"

    html += "<p><i>SafeZone buddies are fellow app users who have completed identity verification and safety training.</i></p>"
    html += "</div>"

    return html

# Main function for route planning
def plan_route(start_lat, start_lon, end_lat, end_lon, time_hour, time_min, time_ampm):
    """Main function to plan and visualize safe routes"""
    # Parse time input
    hour = int(time_hour)
    if time_ampm == "PM" and hour < 12:
        hour += 12
    elif time_ampm == "AM" and hour == 12:
        hour = 0

    current_time = datetime.now().replace(hour=hour, minute=int(time_min))

    # Find routes
    routes = find_safest_route(
        start_lat, start_lon, end_lat, end_lon, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data
    )

    # Generate safety heatmap
    center_lat = (start_lat + end_lat) / 2
    center_lon = (start_lon + end_lon) / 2
    heatmap_data = generate_safety_heatmap(
        center_lat, center_lon, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data
    )

    # Get transit safety information
    transit_safety = get_transit_safety(
        transit_data, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data
    )

    # Create map
    safety_map = create_safety_map(
        center_lat, center_lon, heatmap_data, routes,
        infrastructure_data, transit_safety
    )

    # Get safety alerts
    alerts = predict_safety_alerts(
        end_lat, end_lon, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data, transit_data
    )

    # Find SafeZone buddies
    buddies = find_safezone_buddies(
        start_lat, start_lon, end_lat, end_lon, current_time
    )

    # Format outputs
    map_html = format_map_html(safety_map)
    routes_html = format_route_comparison(routes)
    transit_html = format_transit_info(transit_safety)
    alerts_html = format_safety_alerts(alerts)
    buddies_html = format_safezone_buddies(buddies)

    # Create safety report
    safety_report = create_safety_report(
        end_lat, end_lon, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data
    )

    return map_html, routes_html, transit_html, alerts_html, buddies_html, safety_report

# Function for location safety check
def check_location_safety(lat, lon, time_hour, time_min, time_ampm):
    """Check safety information for a specific location"""
    # Parse time input
    hour = int(time_hour)
    if time_ampm == "PM" and hour < 12:
        hour += 12
    elif time_ampm == "AM" and hour == 12:
        hour = 0

    current_time = datetime.now().replace(hour=hour, minute=int(time_min))

    # Generate safety heatmap
    heatmap_data = generate_safety_heatmap(
        lat, lon, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data
    )

    # Get transit safety information
    transit_safety = get_transit_safety(
        transit_data, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data
    )

    # Create map
    safety_map = create_safety_map(
        lat, lon, heatmap_data, None,
        infrastructure_data, transit_safety
    )

    # Get safety alerts
    alerts = predict_safety_alerts(
        lat, lon, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data, transit_data
    )

    # Format outputs
    map_html = format_map_html(safety_map)
    transit_html = format_transit_info(transit_safety)
    alerts_html = format_safety_alerts(alerts)

    # Create safety report
    safety_report = create_safety_report(
        lat, lon, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data
    )

    # Calculate single safety score
    safety_score = calculate_safety_score(
        lat, lon, current_time,
        city_grid, crime_data, infrastructure_data, sentiment_data
    )

    return map_html, transit_html, alerts_html, safety_report, f"{safety_score:.1f}%"

# Create Gradio interface
with gr.Blocks(title="SafePath AI - Urban Safety Navigator", theme=gr.themes.Soft()) as app:
    gr.Markdown("""
    # SafePath AI - Urban Safety Navigator
    ## Navigate urban spaces safely with AI-powered route planning
    """)

    with gr.Tabs():
        with gr.TabItem("Route Planner"):
            with gr.Row():
                with gr.Column(scale=1):
                    gr.Markdown("### Plan Your Journey")
                    start_lat = gr.Number(label="Start Latitude", value=12.9716)
                    start_lon = gr.Number(label="Start Longitude", value=77.5946)
                    end_lat = gr.Number(label="Destination Latitude", value=12.9866)
                    end_lon = gr.Number(label="Destination Longitude", value=77.6034)

                    with gr.Row():
                        time_hour = gr.Dropdown(
                            choices=[str(i).zfill(2) for i in range(1, 13)],
                            label="Hour",
                            value="08"
                        )
                        time_min = gr.Dropdown(
                            choices=[str(i).zfill(2) for i in range(0, 60, 5)],
                            label="Minute",
                            value="30"
                        )
                        time_ampm = gr.Radio(
                            choices=["AM", "PM"],
                            label="AM/PM",
                            value="PM"
                        )

                    plan_btn = gr.Button("Plan Safe Route", variant="primary")

                with gr.Column(scale=2):
                    map_output = gr.HTML(label="Safety Map")

            with gr.Row():
                routes_output = gr.HTML(label="Route Options")
                transit_output = gr.HTML(label="Transit Information")

            with gr.Row():
                alerts_output = gr.HTML(label="Safety Alerts")
                buddies_output = gr.HTML(label="SafeZone Buddies")

            with gr.Row():
                report_output = gr.Image(label="Safety Analysis")

        with gr.TabItem("Location Safety Check"):
            with gr.Row():
                with gr.Column(scale=1):
                    gr.Markdown("### Check Location Safety")
                    check_lat = gr.Number(label="Latitude", value=12.9716)
                    check_lon = gr.Number(label="Longitude", value=77.5946)

                    with gr.Row():
                        check_hour = gr.Dropdown(
                            choices=[str(i).zfill(2) for i in range(1, 13)],
                            label="Hour",
                            value="08"
                        )
                        check_min = gr.Dropdown(
                            choices=[str(i).zfill(2) for i in range(0, 60, 5)],
                            label="Minute",
                            value="30"
                        )
                        check_ampm = gr.Radio(
                            choices=["AM", "PM"],
                            label="AM/PM",
                            value="PM"
                        )

                    check_btn = gr.Button("Check Safety", variant="primary")
                    safety_score_output = gr.Textbox(label="Current Safety Score")

                with gr.Column(scale=2):
                    check_map_output = gr.HTML(label="Location Safety Map")

            with gr.Row():
                check_transit_output = gr.HTML(label="Nearby Transit")
                check_alerts_output = gr.HTML(label="Safety Alerts")

            with gr.Row():
                check_report_output = gr.Image(label="Safety Analysis")

        with gr.TabItem("About"):
            gr.Markdown("""
            ## About SafePath AI

            SafePath AI is an urban safety navigation system that helps people navigate cities safely by:

            - **Analyzing safety factors** including crime data, infrastructure, transit options, and user reports
            - **Recommending safer routes** and transportation options
            - **Providing real-time alerts** about potential safety issues
            - **Connecting users** with others heading in the same direction through SafeZone Buddies

            ### How It Works

            1. The system combines multiple data sources including:
               - Historical incident data
               - Infrastructure (streetlights, CCTV)
               - Transit occupancy and safety ratings
               - User-reported safety sentiment

            2. Our AI models analyze these factors along with temporal patterns to:
               - Calculate location-specific safety scores
               - Identify optimal routes balancing safety and efficiency
               - Predict potential safety concerns
               - Suggest precautionary measures

            ### Note

            This is a demonstration version using simulated data. In a production environment, the system would:
            - Connect to real-time city data sources
            - Incorporate verified incident reports
            - Use actual infrastructure maps
            - Include real-time transit information
            - Leverage anonymized user safety reports

            ¬© 2025 SafePath AI - Urban Safety Navigator
            """)

    # Set up button actions
    plan_btn.click(
        plan_route,
        inputs=[start_lat, start_lon, end_lat, end_lon, time_hour, time_min, time_ampm],
        outputs=[map_output, routes_output, transit_output, alerts_output, buddies_output, report_output]
    )

    check_btn.click(
        check_location_safety,
        inputs=[check_lat, check_lon, check_hour, check_min, check_ampm],
        outputs=[check_map_output, check_transit_output, check_alerts_output, check_report_output, safety_score_output]
    )

# Launch the app
if __name__ == "__main__":
    app.launch()